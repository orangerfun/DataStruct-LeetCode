# 1. 题目
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度<br>
**示例**<br>
```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```
# 2. 暴力法
先找出所有的子字符串，然后判断子字符串是否是有效的括号子串， 通过两个for循环找出所有的子字符串，那么主要问题是如何判断一个子字符串是有效的括号字符
串， 我们借助堆栈来实现对字符串的判断， 遍历子字符串，如果是"("就加入堆栈， 如果是")", 且堆栈不为空，就从堆栈中pop出一个元素，最后如果栈顶没有"("，
或者遍历完整个子字符串后栈中仍然有元素，那么该子字符串是无效的。这种方法中，我们对每个偶数长度的子字符串都进行判断，
并保存目前为止找到的最长的有效子字符串的长度。<br>

**暴力法见程序bruteforce.py**<br>
**时间复杂度为n平方**

# 3. 动态规划
### 3.1 状态设定
设dp[i]为以字符s[i]结尾的最长有效括号子串长度

### 3.2 状态初始化
当以"("结尾的子串有效的括号长度必定为0， 因此首先初始化所有dp[i]为0， 另外有些特殊位置需要改变， dp[0]肯定为0， dp[1]要分情况，当s[0]="("且
s[1]=")"时dp[1]=2, 其他情况下dp[1]=0

### 3.3 状态转移
当`s[i]=")" and s[i-1]="("`时， `dp[i] = dp[i-2]+2`<br>
当`s[i]=")" and s[i-1]=")"`时， 如果 `s[i-dp[i-1]-1]="("`, `dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2`<br>
注意上面i的取值， 不能使得数组的索引为负<br>

**动态规划程序见dp.py**<br>
**时间复杂度为n**

# 4. 参考
[leetcode题解](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode/)

