# 题目说明
给定一个字符串 s，找到 s 中最长的回文子串<br>
注意：回文子串是指一个字符串正着读与反着读都一样
#### 示例1
    输入: "babad"
    输出: "bab"
    注意: "aba" 也是一个有效答案
#### 示例2
    输入: "cbbd"
    输出: "bb"
# 解法1：动态规划
#### 1. 定义状态
* 记号 s[L, r] 表示原始字符串的一个子串，L、r 分别是区间的左右边界的索引值，使用左闭、右闭区间表示左右边界可以取到。举个例子，当 s = 'babad' 时，s[0, 1] = 'ba' ，s[2, 4] = 'bad'<br>
* dp[L][r] 表示子串 s[L, r]（包括区间左右端点）是否构成回文串，是一个二维布尔型数组
#### 2. 状态转移矩阵
* 当子串只包含 1 个字符，它一定是回文子串
* 当子串包含 2 个以上字符的时候：如果 s[L, r] 是一个回文串，那么这个回文串两边各往里面收缩一个字符（如果可以的话）的子串 s[L + 1, r - 1] 也一定是回文串，即：如果 dp[L][r] == true 成立，一定有 dp[L + 1][r - 1] = true 成立

因此：给出一个子串 s[L, r] ，如果 s[L] != s[r]，那么这个子串就一定不是回文串
如果 s[L] == s[r] 成立，就接着判断 s[L + 1] 与 s[r - 1]，就这样一直循环下去
###### 注意
   * 当原字符串的元素个数为 3 个的时候，如果左右边界相等，那么去掉它们以后，只剩下 1 个字符，它一定是回文串，故原字符串也一定是回文串
   * 当原字符串的元素个数为 2 个的时候，如果左右边界相等，那么去掉它们以后，只剩下 0 个字符，显然原字符串也一定是回文串
   
由上面两点，只要 s[L + 1, r - 1] 至少包含两个元素，就有必要继续做判断，否则直接根据左右边界是否相等就能得到原字符串的回文性。而“s[L + 1, r - 1] 至少包含两个元素”等价于 L + 1 < r - 1，整理得 L - r < -2，或者 r - L > 2

    状态转移方程为：dp[L, r] = (s[L] == s[r] and (r - L <= 2 or dp[L + 1, r - 1]))
# 解法2：中心扩展法
基本思想：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。要注意一个细节：回文串的长度可能是奇数，也可能是偶数<br>

针对奇偶长度设计如下方法：

    如果传入重合的索引编码，进行中心扩散，此时得到的最长回文子串的长度是奇数
    如果传入相邻的索引编码，进行中心扩散，此时得到的最长回文子串的长度是偶数
    

