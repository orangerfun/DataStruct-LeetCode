# 题目说明
**子序列：** 子序列和子字符串不同，子序列可以是由母字符串中不同位置的元素组成（各元素之间的相对位置不变），
子字符串必须是相邻的元素组成<br>
#### 例1
    A = "HellowWord"     B = "Loop"
    则 A 和 B 的最长公共子序列为 "loo" ，长度为3
# 动态规划
**定义状态**

    res[i][j] 为截止到字符串 A 的第i个元素和字符串B的第j个元素的公共子序列的最大长度
**状态转移**<br>
首先考虑A和B的最后一个元素
* 如果 A[n] = B[m], 即A、B的最后一个元素相同，则该元素必定在公共子序列中，
因此只需找res[n-1][m-1]\(即A前n-1个元素和B中前m-1个元素的最长公共子序列)
* 如果 A[n] != B[m], 将产生两个子问题，res[n-1][m]和res[n][m-1],此时最大子序列就在两者之间查找即max{res[n-1][m], res[n][m-1]}

      when i = 0 or j = 0, res[i][j] = 0;
      when A[i] = B[j], res[i][j] = res[i-1][j-1] + 1;
      when A[i] != B[j], res[i][j] = max{res[i][j-1], res[i-1][j]}
## 如何找到具体子序列
假设有如下两个字符串：  S1 = “123456778”    S2 = “357486782” 其最终的动态规划填表结果如下：<br>

![](https://github.com/orangerfun/LeetCode/raw/master/最长公共子序列/0.png)

根据上面的状态转移公式，从最后一个元素到推出S1和S2的LCS(最长公共子序列)<br>
* res[8][9] = 5，且S1[8] != S2[9]，所以倒推回去，res[8][9]的值来源于c[8][8]的值(因为res[8][8] > res[7][9])
* res[8][8] = 5, 且S1[8] = S2[8], 所以倒推回去，res[8][8]的值来源于 res[7][7]
* 以此类推，如果遇到S1[i] != S2[j] ，且res[i-1][j] = res[i][j-1] 这种存在分支的情况，这里都选择一个方向（之后遇到这样的情况，也选择相同的方向，要么都往左，要么都往上）

此处方向选择向上，得到如下递推图

![](https://github.com/orangerfun/LeetCode/raw/master/最长公共子序列/1.png)

       注意：红色方块就是最长子序列中的元素，他们一起组成最长子序列
       在从最后一个元素向前寻找最长子序列时，首先将方向固定（如都选择向上），然后当碰到s1[i]==s2[j]时，将该元素append到列表中，当遍历完整个表时，将该列表reverse就得到最长公共子序列





