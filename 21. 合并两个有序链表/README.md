# 题目说明
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 <br>
**例**：<br>

      输入：1->2->4, 1->3->4
      输出：1->1->2->3->4->4
# 解法1：递归
递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：<br>

    list1[0]+merge(list1[1:],list2)   list1[0]<list2[0]
    list2[0]+merge(list1,list2[1:])   otherwise
* 特殊的，如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。
否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。
* 如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。
# 解法2：
使用一个新的链表L3来存储合并后的链表；首先分别从L1,L2中从头取出一个元素，比较大小，将小的放到L3中，再取出一个元素进行比较，重复上述操作，
直到有一个链表为空为止，然后将还有元素的链表接到L3的后面<br>
**例：**

    L1: 1->2->4,  L2: 1->3->4
    step1： L1中取1， L2中取1，L1 <= L2: 则L3->1(L1)
    step2： L1中取2， L2(1) < L1(2): 则L3->1->1
    step3:  L2中取3， L1(2) < L2(3): 则L3->1->1->2
    step4:  L1中取4...如此重下去，直到一个链表为空，然后将未空的链表接到L3最后
