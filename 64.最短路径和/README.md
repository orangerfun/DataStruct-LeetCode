# 1.题目
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。每次只能向下或者向右移动一步。

    输入:grid = 
    [
      [1,3,1],
      [1,5,1],
      [4,2,1]
              ]
    输出: 7
    解释: 因为路径 1→3→1→1→1 的总和最小。
# 2.递归算法
在每个元素位置，都有两个方向可以走（除了在最下和最右的边上），例如（如上面的例子中）第一元素可以像由走，也可以向下走，
那么从第一个元素到右下角的元素的最短路径是`d[0][0]=grid[0][0]+min(dp[0][1],dp[1][0])`,以此类推，`dp[i][j] = grid[i][j]+min(dp[i+1][j],dp[i][j+1])`
其中`dp[i][j]`表示位置（i，j）到右下角位置的最短路径；当i或者j到最下面或者右边矩阵边界时，此时，只有一条路可走，要不一直向下，要不一直往右，
这也是递归的结束条件<br>
<br>
综上，递推式为：<br>

    dp[i][j] = grid[i][j]+min(dp[i+1][j],dp[i][j+1])  i != len(grid) and j != len(grid[0])
    dp[i][j] = sum(grid[i][j:])   i == len(grid)
    dp[i][j] = sum( [grid[k][j] for k in range(i, len(grid))] )   j == len(grid[0])
    将上述dp[i][j]写成函数就是递归了
    
**程序见 digui.py**<br>
**时间复杂度**： 每次都有两种选择 因此为 2^(m+n) , m,n是矩阵的形状<br>
**空间复杂度**： m+n
# 3.动态规划
动态规划算法和递归有相似处，递归从前向后，动态规划从后向前；我们新建一个额外的 dpdp 数组，与原矩阵大小相同。
在这个矩阵中，dp(i, j) 表示从坐标 (i, j) 到右下角的最小路径权值。我们初始化右下角的 dp 值为对应的原矩阵值，然后去填整个矩阵，
对于每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：

    dp[i][j] = grid[i][j]+min(dp[i+1][j],dp[i][j+1])                   i != len(grid) and j != len(grid[0])
    dp[i][j] = dp[i][j+1] + grid[i][j]                                 i == len(grid)
    dp[i][j] = dp[i+1][j] + grid[i][j]                                 j == len(grid[0])
**程序见 dp.py**
